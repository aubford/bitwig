/**
 * Represents a knockout-enhanced, windowed view on launchable clip slots,
 * Default orientation: Scenes x Tracks
 *
 * Author: Lennart Pegel - https://github.com/justlep
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 *
 * @param name {String}
 * @param numTracks {Number}
 * @param numSends {Number}
 * @param [numScenes] {Number} optional; must be 0 or empty if no `trackBank` is given
 * @param [trackBank] {TrackBank|null} if null, a MainTrackBank with 0 scenes will be created
 * @constructor
 */
lep.MatrixWindow = lep.util.extendClass(lep.TrackWindow, {
    _init: function(name, numTracks, numSends, numScenes, trackBank) {
        lep.util.assertNumberInRange(numScenes, 1, lep.TrackWindow.MAX_SCENES, 'Invalid numScenes={} for MatrixWindow {}', numScenes, name);
        this._super.apply(this, arguments);

        var self = this,
            totalLauncherSlots = numTracks * numScenes,
            // sceneBank = trackBank.sceneBank(),
            slotBanksByTrack = this.tracks.map(function(track) {
                var slotBank = track.clipLauncherSlotBank();
                slotBank.setIndication(true);
                return slotBank;
            }),
            launcherSlots = lep.util.generateArrayTableBased(numTracks, numScenes, function(trackIndex, sceneIndex, index) {
                return new lep.LauncherSlot(trackIndex, sceneIndex, slotBanksByTrack[trackIndex]);
            }),
            totalSelectableScenes = ko.observable(1000), // FIXME it is even possible to determine this number?
            maxScrollPosition = ko.computed(function() {
                return totalSelectableScenes() - numScenes;
            });

        // init play
        slotBanksByTrack.forEach(function(slotBank, trackIndex) {
            slotBank.addPlaybackStateObserver(function(sceneIndex, slotState, isQueued) {
                const STATE = lep.LauncherSlot.STATE;
                var launcherSlotIndex = ((sceneIndex * numTracks) + trackIndex),
                    launcherSlot = launcherSlots[launcherSlotIndex],
                    newState =
                    (slotState === 0) ? (isQueued ? STATE.STOP_QUEUED : STATE.STOPPED) :
                    (slotState === 1) ? (isQueued ? STATE.PLAY_QUEUED : STATE.PLAYING) :
                    (slotState === 2) ? (isQueued ? STATE.RECORD_QUEUED : STATE.RECORDING) : STATE.OTHER;

                // lep.logDebug('New state for {} -> {}', launcherSlot.name, newState);
                launcherSlot.state(newState);
            });

            slotBank.addHasContentObserver(function(sceneIndex, hasContent) {
                var launcherSlotIndex = ((sceneIndex * numTracks) + trackIndex),
                    launcherSlot = launcherSlots[launcherSlotIndex];

                // lep.logDebug('New hasContent for {} -> {}', launcherSlot.name, hasContent);
                launcherSlot.hasContent(hasContent);
            });
        });

        this.sceneScrollPosition = ko.observable(0).updatedBy(function(obs) {
            self.trackBank.addSceneScrollPositionObserver(obs, 0);
        });
        this.canMoveSceneBack = ko.computed(function() {
            return !!self.sceneScrollPosition();
        });
        this.canMoveSceneForth = ko.computed(function() {
            return self.sceneScrollPosition() < maxScrollPosition();
        });

        this.moveSceneForth = function() {
            self.trackBank.scrollScenesDown();
        };
        this.moveScenePageForth = function() {
            self.trackBank.scrollScenesPageDown();
        };
        this.moveSceneBack = function() {
            self.trackBank.scrollScenesUp();
        };
        this.moveScenePageBack = function() {
            var newScenePos = Math.max(0, self.sceneScrollPosition() - numScenes);
            self.trackBank.scrollToScene(newScenePos);
        };

        /**
         * Generates a ControlSet instance that fits all launcherSlots of this MatrixWindow.
         * @param controlCreatorFn {function} a function that creates the controls, e.g. function(colIndex, rowIndex, absoluteIndex){}
         * @returns {lep.ControlSet}
         */
        this.createMatrixControlSet = function(controlCreatorFn) {
            return new lep.ControlSet('Matrix', totalLauncherSlots, function(index) {
                var rowIndex = Math.floor(index / numTracks),
                    colIndex = index % numTracks;

                return controlCreatorFn(colIndex, rowIndex, index);
            });
        };

        /**
         * Generates a ValueSet instance fill with values generated by a given `valueCreatorFn`.
         *
         * @param valueCreatorFn {function} a function supposed to return the {@link BaseValue} instances for the set,
         *                                  e.g. function(launcherSlot) { return new BaseValue(..) }
         * @returns {lep.ValueSet}
         */
        this.createLauncherSlotValueSet = function(valueCreatorFn) {
            return new lep.ValueSet('LauncherSlotValues', totalLauncherSlots, 1, function(launcherSlotIndex) {
                return valueCreatorFn( launcherSlots[launcherSlotIndex] );
            });
        };
    }
});

/**
 * Creates a MatrixWindow instance with a main track bank.
 * @param numTracks {Number}
 * @param numSends {Number}
 * @param numScenes {Number}
 * @static
 */
lep.MatrixWindow.createMain = function(numTracks, numSends, numScenes) {
    return new lep.MatrixWindow('MainMatrixWindow', numTracks, numSends, numScenes);
};